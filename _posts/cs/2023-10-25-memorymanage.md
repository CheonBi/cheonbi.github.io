---
title: 메모리관리
excerpt: 운영체제(OS)

categories:
    - CS
---

## 서론
메모리 관리는(Memory Management)는 하나의 물리적인 메모리 공간에서 여러 개의 프로세스를 어떻게 돌릴 것인가에 대한 탐구이다.

```
- 여러개의 프로세스를 하나의 메인 메모리 상에서 어떻게 돌릴 것인가?
- 프로세스마다 점유하고 있는 메모리 사이의 간섭을 어떻게 줄일 것인가?
- 적은 오버헤드를 추구하면서 어떻게 하면 메모리 공간을 낭비없이 효율적으로 활용할 것인가?
```

---
## 1. 주소 공간(Address Spaces)

- 물리적 주소 공간(Physical Address Space): 물리적 주소 공간은 하드웨어 실제로 존재하는 주소의미, 메모리의 용량 자체를 의미
- 논리적 주소 공간(Logical Address Space): 논리적 주소 공간은 **프로세스 관점**에서 자신이 가지고 있는 메모리 크기를 의미 
- 프로그램은 디스크에 Binary Executable File 형태로 존재함.
- 프로그램의 실행은 곧 프로세스의 Context가 메모리에 올려지고, CPU에 의해 실행됨

즉, 프로세스가 실행되면 해당 프로세스가 가진 명령어들과 데이터를 메모리에 올려 사용하게 되고, 프로세스가 종료되면 해제되어 다른 프로세스들이 사용가능

1. 컴파일과 어셈블링 과정이 끝난 프로그램에는 논리적 주소가 부여
2. 링킹 과정에서 여러 라이브러리들과 엮이는 과정이 발생
3. 프로그램이 로드 될때 물리적 주소에 매핑됨. 하위 메모리부터 채워져 나가며, 하드웨어 레지스터(MMU)에 의해 주소 변환이 이루어짐

---

## 2. MMU
``구성``
- 별도의 칩으로 된 경우도 있지만 통상 CPU의 일부
- 데스크탑 또는 고가 시스템에서는 MMU가 지원
- 소형/저가를 위한 임베디드 시스템에서는 지원이 안될 수 있음
- 즉, MMU는 시스템의 가격과 복잡성을 증가시킴
- 가상 메모리를 실제 메모리로 사상시키는데 필요한 표를 유지하도록 소량의 메모리를 갖고 있음

``역할``
- 가상주소를 실제 물리주소로 변환
- 메모리 보호를 위한 메모리 접근제어
- 운영체제 영역과 사용자 영역을 구분 관리
- 캐시 메모리 관리
- 버스 중재


## 3. 가상메모리
가상 메모리는 메모리를 관리하는 방법의 하나로
각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식
실제 주기억장치(RAM)보다 큰 메모리 영역을 제공하는 방법으로 사용됨

``개념``  
**RAM은 항상 부족하다**
- 시스템에서 실행 되는 가장 큰 용량의 어플리케이션보다 메모리가 커야한다.
- 두 개 이상의 어플리케이션이 실행되는 멀티태스킹 상황은 더욱 많은 메모리가 필요하다.
- 가상메모리는 프로그램이 차지 하는 주소공간의 개념에 대해 조금 다르게 접근

가상 메모리를 사용하는 OS에서는 `프로그램을 실행하는데 얼마나 많은 메모리가 필요한가?` 보다 `프로그램을 실행하는데 필요한 최소한의 메모리는 얼마인가?`에 집중한다.

- 메모리 접근은 순차적이고 지역화 되어있다.
- 이러한 특성으로 인해 프로그램들은 필요한 메모리보다 훨씬 적은 용량으로 실행된다.
- 즉, 어플리케이션의 일부분만 메모리에 할당되어 실행됨
- 주 메모리(RAM)에 할당 되지 않는 부분은 Disk에 위치함

```
프로그램이 실행될 때, 실행에 필요한 일부분만 메모리에 할당되며 나머지 부분은 디스크에 남게됨
즉, Disk가 RAM의 보조 기억장치 처럼 작동
```

``가상 메모리의 주소와 물리 메모리주소는 일치하지 않는다.``
- 가상 메모리의 주소와 물리 메모리 주소를 1 to 1 대응 시켜야함
- MMU를 통해 가상 메모리 주소 -> 물리 메모리 주소로 변환
- 모든 메모리 주소를 MMU를 거쳐 변환하는 것은 오버헤드가 크기때문에 메모리를 일정 단위(페이지, Page)로 쪼개서 관리
- 각 페이지를 독립된 항목으로 처리함
- 페이지 및 주소 번역 정보를 기억하는 작업이 가상메모리를 이용하는데 가장 중요한 절차


``요구페이지(Demand Paging)``
- **CPU가 요청할때**, 프로세스의 데이터를 RAM에 할당 하는것
- 즉, 처음부터 프로세스의 모든 데이터를 메모리에 할당하지는 않는다.

``Swapping``
- CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억 장치를 내보냄(Swap-Out)
- 다른 프로세스의 메모리를 불러옴(Swap-In)
- Swap 작업에는 디스크 전송시간이 들기 때문에 메모리 공간이 부족할 때 Swapping이 이루어짐

``가상메모리 관리``

쪼개는 방법에 따라 페이징 기법, 세그맨테이션 기법으로 나뉜다.

## 4. 가상메모리 관리 기법(Paging, Segmentation)
**페이징과 세그멘테이션은 [메모리 단편화]를 해결하기 위해 제시됨**

#### ``메모리 단편화``
- 할당된 메모리 사이에 빈공간이 생기는 현상
- 단편화 발생 시, 새로운 메모리 할당 중 남은 메모리 공간이 충분함에도 할당하지 못하는 상황이 발생
- 메모리 할당은 연속적인 공간에서만 이루어지기 때문
- 단편화는 ``외부 단편화`` - ``내부단편화`` 2가지 현상으로 나뉨

> 내부 단편화

- 메모리 할당 시, 프로세스가 필요로 하는 용량보다 더 큰 메모리가 할당 되어 메모리 공간이 낭비되는 현상

> 외부 단편화

- 메모리 할당/해제되는 작업이 반복되어, 메모리 공간 사이에 사용되지 않는 불연속적인 빈 공간이 존재 하게 되는 상황

---

#### 페이징
- 가상 메모리의 공간을 일정 단위(Page)로 나누고, 1 to 1 대응되는 물리 메모리 공간도 일정 단위(Frame)으로 나눈다.
- 특수한 경우가 아니라면 Page와 Frame의 단위는 같다.
- PageTable을 통해 Page -> Frame을 1 to 1 매핑시켜 물리 메모리에 접근하는 방식

**실제 메모리를 불연속적으로 사용, 연속적인 공간인 것처럼 활용하여 외부 단편화를 해결**

![paging](/assets/images/paging.png){: width="450"}

``페이지 테이블``
- 가상 메모리주소와 물리 메모리 주소가 1 to 1 매핑되어 있는 테이블
- 페이지 번호, 해당 페이지에 적재되어 있는 프레임의 시작 주소로 이루어져 있다.
- 해당 페이지에 적재되어 있는 프레임이 없는 경우(물리메모리에 올라와 있지 않는 경우) invalid 값이 들어감
- 각 프로세스마다 존재하며, 프로세스가 실행될 때 생성됨. 각 프로세스의 고유한 가상 주소 공간에 따라 생성됨


``동작방식``

![pagingdetail](/assets/images/pagingdetail.png){: width="550"}

1. Virtual Address와 Page Table Ptr값을 더해 Page Table에 접근한다.
- PTBR(Page Table Base Register)에는 PageTable의 주소가 적재되어 있음

2. Present bit를 확인
- Present bit == 1 : 물리메모리에 필요한 데이터가 적재되어 있음, 계속 진행
- Present bit == 0 : 물리메모리에 필요한 데이터가 적재되어 있지 않음, PageFault 발생, 해결 후 진행

3. 해당하는 Frame Number를 찾고 가상 주소를 실제 주소로 변환
- Page의 크기와 Frame의 크기가 동일하기 때문에 Offset을 그대로 이용할 수 있다.

4. Main Memory의 Frame에 접근하여 작업을 진행

``페이지 폴트``
1. 가상 메모리 기법에서 모든 데이터가 메인 메모리에 적재 되지 않는다.
2. 그럼 찾고자 하는 페이지가 현재 메인 메모리에 적재되어 있지 않다면?

> 위 문제를 정리하면, 어떤 프로세스가 자신의 가상 메모리 공간에는 존재하지만  RAM에는 현재 없는 데이터에 접근하려는 문제이다.

이러한 현상을 ``페이지 폴트`` 라고 한다. ``인터럽트``이다.

1. CPU는 물리 메모리를 확인하여 페이지가 없으면 Trap을 발생하여 OS에 전달
2. OS는 CPU의 동작을 잠시 중지
3. OS는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인, 없으면 프로세스를 중단
4. PageFault면, 현재 물리 메모리에 비어있는 프레임(Free Frame)이 있는지 확인한다. 또한 OS가 해당 페이지를 저장공간에서 가져온다. 
5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다. 
    - 비어있는 프레임이 없다면 희생 프레임을 골라야 하는데, 이 과정에서 페이지 교체 알고리즘이 사용된다.
6. 잠시 중단된 CPU를 다시 동작시킴

---

### 세그멘테이션
- 프로세스를 일정 크기(Page, Frame)이 아닌 논리적 내용 단위(Segment)로 자름
- 프로세스를 Segment의 집합으로 생각함
- 물리적인 크기의 단위가 아닌 논리적 내용의 단위
- 세그먼트의 크기는 일반적으로 같지 않음
- method, procedure, function, stack, object 등 함수 단위로 나눔

``동작방식``  
페이징과 동일한 흐름으로 진행된다. 다만, 논리 주소 앞 비트들은 페이징 번호가 아니라 세그먼트 번호이다.


---

### Paging & Segmentation

페이징과 세그멘테이션 비교시 세그멘테이션이 더 유용해 보인다.  
왜냐하면, 페이징은 
- 프로세스를 같은 단위로 자르게 되므로 중요한 부분과 중요하지 않은 부분이 같은 페이지 안에 할당 될 수 있다. 
- 코드 영역이 같은 단위로 잘리기 때문에 모호하게 잘려질 위험이 있다.

하지만 세그멘테이션은
- 중요하지 않는 세그먼트를 논리적인 내용 측면으로 자를 수 있다.
- 보호와 공유의 기능이 수행 하기 더욱 쉽다.
- 물리적인 크기가 다른 각 세그먼트를 메모리에 적재하기 위해 동적 메모리 할당을 해야한다. 이는 외부 단편화가 발생 할 수 있다.

**이에 따라, 세그먼트를 페이징하는 방법이 고안되었다**  

**Paged Segmentation**

``세그멘테이션과 페이징 기법을 함께 사용함으로써 각자의 단점을 가리고 장점을 극대화 한다.``

- Paging System과 Segmentation System을 결합한 형태이다. 
- Segment들의 크기는 제각기 다르며, 일반적으로 한 Page보다 크기가 크다.
- Page는 하나의 Segment를 고정된 크기로 분할한 형태이다.


![](/assets/images/pagedsegmentation.png){: width="550"}



1. 우선 프로세스를 세그먼트 단위로 자른다.(논리적인 단위, 가변적)
2. 외부 단편화가 발생 할 수 있기 때문에 잘라진 세그먼트를 다시 일정한 페이지 단위로 자른다.
3. 메모리에 적재 시 각 세그먼트가 페이징에 의해 일정 단위로 다시 잘린 후 적재되었기 때문에 외부 단편화의 발생을 막을 수 있다.


``세그먼트 테이블과 페이지 테이블을 순차적으로 거치기 때문에``  
``일반적인 페이징 혹은 세그멘테이션 방식보다 속도가 느려지게 된다.``